/**
 * Capability that makes any actor pickupable by players.
 * Add this capability to any actor to make it interactable and pickupable.
 * This capability handles all pickup logic, collision detection, and visual effects.
 */
class UPickupCapability : UBaseCapability
{
    // The item this pickup represents (optional - if null, uses actor data)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pickup")
    UInventoryItemData ItemToPickup;

    // Auto-generated item settings (used when ItemToPickup is null)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Auto Pickup")
    FString AutoItemName = "";

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Auto Pickup")
    FString AutoItemDescription = "";

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Auto Pickup")
    FString AutoItemCategory = "Pickup";

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Auto Pickup")
    float AutoItemWeight = 1.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Auto Pickup")
    bool bUseActorNameAsItemName = true;

    // Interaction distance
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pickup")
    float InteractionRadius = 150.0f;

    // Whether this pickup can be picked up multiple times
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pickup")
    bool bIsReusable = false;

    // Whether this pickup has been collected
    UPROPERTY(BlueprintReadOnly, Category = "Pickup")
    bool bIsCollected = false;

    // Visual feedback settings
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Visual")
    bool bRotatePickup = true;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Visual")
    float RotationSpeed = 90.0f; // degrees per second

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Visual")
    bool bBobUpAndDown = true;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Visual")
    float BobHeight = 20.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Visual")
    float BobSpeed = 2.0f;

    // Auto-create collision sphere if none exists
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pickup")
    bool bAutoCreateCollisionSphere = true;

    // Collision component for detecting nearby players (created automatically if needed)
    UPROPERTY()
    USphereComponent InteractionSphere;

    // Mesh component to apply visual effects to (auto-detected if not set)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pickup")
    UStaticMeshComponent TargetMeshComponent;

    // Internal state for visual effects
    float OriginalZ;
    float TimeAccumulator = 0.0f;
    FTransform OriginalMeshTransform;
    bool bVisualEffectsInitialized = false;

    // Auto-generated inventory item data
    UPROPERTY()
    UInventoryItemData AutoGeneratedItemData;

    UFUNCTION(BlueprintOverride)
    bool ShouldBeActive() const
    {
        // Always active when attached to an actor
        return GetOwner() != nullptr;
    }

    UFUNCTION(BlueprintOverride)
    void OnCapabilityActivated()
    {
        AActor OwnerActor = GetOwner();
        if (OwnerActor == nullptr)
            return;

        // Store original Z position for bobbing
        OriginalZ = OwnerActor.GetActorLocation().Z;

        // Find or create mesh component
        SetupMeshComponent();

        // Find or create collision sphere
        SetupCollisionSphere();

        // Set up the mesh based on the item
        UpdateMeshFromItem();

        // Generate auto item data if no explicit item is set
        if (ItemToPickup == nullptr)
        {
            CreateAutoGeneratedItemData();
        }

        // Bind overlap events
        if (InteractionSphere != nullptr)
        {
            InteractionSphere.OnComponentBeginOverlap.AddUFunction(this, n"OnInteractionBeginOverlap");
            InteractionSphere.OnComponentEndOverlap.AddUFunction(this, n"OnInteractionEndOverlap");
        }

        FString ItemName = (ItemToPickup != nullptr) ? ItemToPickup.GetDisplayName() : "None";
        Log(f"PickupCapability activated on {OwnerActor.GetName()} with item: {ItemName}");
    }

    UFUNCTION(BlueprintOverride)
    void OnCapabilityDeactivated()
    {
        // Clean up any created components
        if (InteractionSphere != nullptr && bAutoCreateCollisionSphere)
        {
            InteractionSphere.DestroyComponent();
            InteractionSphere = nullptr;
        }

        // Reset visual effects
        if (bVisualEffectsInitialized && TargetMeshComponent != nullptr)
        {
            TargetMeshComponent.SetRelativeTransform(OriginalMeshTransform);
        }
    }

    void SetupMeshComponent()
    {
        AActor OwnerActor = GetOwner();
        if (OwnerActor == nullptr)
            return;

        // If no target mesh specified, try to find one automatically
        if (TargetMeshComponent == nullptr)
        {
            TargetMeshComponent = Cast<UStaticMeshComponent>(OwnerActor.GetComponentByClass(UStaticMeshComponent));
        }

        // Store original transform for visual effects
        if (TargetMeshComponent != nullptr)
        {
            OriginalMeshTransform = TargetMeshComponent.GetRelativeTransform();
            bVisualEffectsInitialized = true;
        }
    }

    void SetupCollisionSphere()
    {
        AActor OwnerActor = GetOwner();
        if (OwnerActor == nullptr)
            return;

        // Try to find existing sphere component
        InteractionSphere = Cast<USphereComponent>(OwnerActor.GetComponentByClass(USphereComponent));

        // Create one if none exists and auto-create is enabled
        if (InteractionSphere == nullptr && bAutoCreateCollisionSphere)
        {
            InteractionSphere = USphereComponent::Create(OwnerActor);
            
            // Attach to root component
            USceneComponent RootComp = OwnerActor.GetRootComponent();
            if (RootComp != nullptr)
            {
                InteractionSphere.AttachToComponent(RootComp);
            }
        }

        // Configure the interaction sphere
        if (InteractionSphere != nullptr)
        {
            InteractionSphere.SetSphereRadius(InteractionRadius);
            InteractionSphere.SetCollisionEnabled(ECollisionEnabled::QueryOnly);
        }
    }

    UFUNCTION(BlueprintOverride)
    void TickCapability(float DeltaTime)
    {
        if (bIsCollected && !bIsReusable)
            return;

        AActor OwnerActor = GetOwner();
        if (OwnerActor == nullptr)
            return;

        TimeAccumulator += DeltaTime;

        // Handle rotation
        if (bRotatePickup)
        {
            FRotator CurrentRotation = OwnerActor.GetActorRotation();
            CurrentRotation.Yaw += RotationSpeed * DeltaTime;
            OwnerActor.SetActorRotation(CurrentRotation);
        }

        // Handle bobbing
        if (bBobUpAndDown)
        {
            FVector CurrentLocation = OwnerActor.GetActorLocation();
            float BobOffset = Math::Sin(TimeAccumulator * BobSpeed) * BobHeight;
            CurrentLocation.Z = OriginalZ + BobOffset;
            OwnerActor.SetActorLocation(CurrentLocation);
        }
    }

    void UpdateMeshFromItem()
    {
        UInventoryItemData CurrentItem = GetCurrentItemData();
        
        if (CurrentItem != nullptr && CurrentItem.HasValidMesh() && TargetMeshComponent != nullptr)
        {
            TargetMeshComponent.SetStaticMesh(CurrentItem.ItemMesh);
            
            if (CurrentItem.ItemMaterial != nullptr)
            {
                TargetMeshComponent.SetMaterial(0, CurrentItem.ItemMaterial);
            }

            // Apply any transform from the item data
            FTransform ItemTransform = CurrentItem.GetHeldItemTransform();
            TargetMeshComponent.SetRelativeTransform(ItemTransform);
        }
        else if (CurrentItem != nullptr)
        {
            AActor OwnerActor = GetOwner();
            if (OwnerActor != nullptr)
            {
                Log(f"PickupCapability on {OwnerActor.GetName()}: No valid mesh component or item mesh found");
            }
        }
    }

    void CreateAutoGeneratedItemData()
    {
        AActor OwnerActor = GetOwner();
        if (OwnerActor == nullptr)
            return;

        // Create a new inventory item data from the actor
        AutoGeneratedItemData = Cast<UInventoryItemData>(NewObject(this, UInventoryItemData));
        if (AutoGeneratedItemData == nullptr)
            return;

        // Set item name
        if (bUseActorNameAsItemName || AutoItemName.IsEmpty())
        {
            AutoGeneratedItemData.ItemName = OwnerActor.GetName().ToString();
        }
        else
        {
            AutoGeneratedItemData.ItemName = AutoItemName;
        }

        // Set description
        if (AutoItemDescription.IsEmpty())
        {
            AutoGeneratedItemData.Description = f"A {AutoGeneratedItemData.ItemName} that can be picked up.";
        }
        else
        {
            AutoGeneratedItemData.Description = AutoItemDescription;
        }

        // Set other properties
        AutoGeneratedItemData.ItemCategory = AutoItemCategory;
        AutoGeneratedItemData.ItemWeight = AutoItemWeight;

        // Try to get mesh and material from the actor
        if (TargetMeshComponent != nullptr)
        {
            UStaticMesh ActorMesh = TargetMeshComponent.GetStaticMesh();
            if (ActorMesh != nullptr)
            {
                AutoGeneratedItemData.ItemMesh = ActorMesh;
            }

            // Get the first material
            UMaterialInterface ActorMaterial = TargetMeshComponent.GetMaterial(0);
            if (ActorMaterial != nullptr)
            {
                AutoGeneratedItemData.ItemMaterial = ActorMaterial;
            }

            // Copy the current transform as the held item transform
            FTransform CurrentTransform = TargetMeshComponent.GetRelativeTransform();
            AutoGeneratedItemData.HeldItemOffset = CurrentTransform.Translation;
            AutoGeneratedItemData.HeldItemRotation = CurrentTransform.Rotator();
            AutoGeneratedItemData.HeldItemScale = CurrentTransform.Scale3D;
        }

        Log(f"Auto-generated inventory item data for {OwnerActor.GetName()}: '{AutoGeneratedItemData.ItemName}'");
    }

    UInventoryItemData GetCurrentItemData() const
    {
        // Return explicit item data if set, otherwise return auto-generated
        if (ItemToPickup != nullptr)
        {
            return ItemToPickup;
        }
        return AutoGeneratedItemData;
    }

    UFUNCTION()
    void OnInteractionBeginOverlap(UPrimitiveComponent OverlappedComponent, AActor OtherActor, UPrimitiveComponent OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&in Hit)
    {
        // Check if the overlapping actor has an interaction capability
        UInteractionCapability InteractionCap = UInteractionCapability::Get(OtherActor);
        if (InteractionCap != nullptr)
        {
            InteractionCap.RegisterInteractable(GetOwner());
        }
    }

    UFUNCTION()
    void OnInteractionEndOverlap(UPrimitiveComponent OverlappedComponent, AActor OtherActor, UPrimitiveComponent OtherComp, int32 OtherBodyIndex)
    {
        // Remove this pickup from the interaction capability
        UInteractionCapability InteractionCap = UInteractionCapability::Get(OtherActor);
        if (InteractionCap != nullptr)
        {
            InteractionCap.UnregisterInteractable(GetOwner());
        }
    }

    // Called by interaction capability when player interacts
    UFUNCTION(BlueprintCallable, Category = "Pickup")
    bool TryPickup(AActor InteractingActor)
    {
        if (bIsCollected && !bIsReusable)
        {
            Log("Pickup already collected and not reusable");
            return false;
        }

        UInventoryItemData CurrentItem = GetCurrentItemData();
        if (CurrentItem == nullptr)
        {
            Log("No item to pickup");
            return false;
        }

        // Try to add to inventory
        UInventoryComponent Inventory = UInventoryComponent::Get(InteractingActor);
        if (Inventory == nullptr)
        {
            Log("Interacting actor has no inventory");
            return false;
        }

        bool bSuccess = Inventory.AddItemToFirstAvailableSlot(CurrentItem);
        if (bSuccess)
        {
            Log(f"Successfully picked up {CurrentItem.GetDisplayName()}");
            OnPickedUp(InteractingActor);
            return true;
        }
        else
        {
            Log("Inventory is full");
            return false;
        }
    }

    void OnPickedUp(AActor InteractingActor)
    {
        bIsCollected = true;

        AActor OwnerActor = GetOwner();
        if (OwnerActor == nullptr)
            return;

        if (!bIsReusable)
        {
            // Hide the pickup
            OwnerActor.SetActorHiddenInGame(true);
            OwnerActor.SetActorEnableCollision(false);
            
            // Optionally destroy after a delay
            OwnerActor.SetLifeSpan(1.0f);
        }

        // Broadcast pickup event
        OnItemPickedUp(InteractingActor, GetCurrentItemData());
    }

    // Override this or bind to it for custom pickup behavior
    UFUNCTION(BlueprintCallable, Category = "Pickup")
    void OnItemPickedUp(AActor InteractingActor, UInventoryItemData PickedUpItem)
    {
        // Base implementation - override for custom behavior
        // This can be overridden in Blueprint or by binding to delegates
    }

    // Utility functions
    UFUNCTION(BlueprintCallable, Category = "Pickup")
    FString GetInteractionText() const
    {
        UInventoryItemData CurrentItem = GetCurrentItemData();
        if (CurrentItem != nullptr)
        {
            return f"Press F to pick up {CurrentItem.GetDisplayName()}";
        }
        return "Press F to interact";
    }

    UFUNCTION(BlueprintCallable, Category = "Pickup")
    bool CanBePickedUp() const
    {
        return GetCurrentItemData() != nullptr && (!bIsCollected || bIsReusable);
    }

    UFUNCTION(BlueprintCallable, Category = "Pickup")
    void ResetPickup()
    {
        bIsCollected = false;
        
        AActor OwnerActor = GetOwner();
        if (OwnerActor != nullptr)
        {
            OwnerActor.SetActorHiddenInGame(false);
            OwnerActor.SetActorEnableCollision(true);
            OwnerActor.SetLifeSpan(0.0f); // Cancel destruction
        }
    }

    // Configuration helpers
    UFUNCTION(BlueprintCallable, Category = "Pickup")
    void SetPickupItem(UInventoryItemData NewItem)
    {
        ItemToPickup = NewItem;
        UpdateMeshFromItem();
    }

    UFUNCTION(BlueprintCallable, Category = "Pickup")
    void SetInteractionRadius(float NewRadius)
    {
        InteractionRadius = NewRadius;
        if (InteractionSphere != nullptr)
        {
            InteractionSphere.SetSphereRadius(InteractionRadius);
        }
    }
};
